// /Users/mac1/Desktop/ewr_editor/src/ewr/parseWrestlerDat.ts

import schemaJson from "./wrestler_dat_schema.json";

type FieldType = "u8" | "u16le" | "ascii_fixed";

type SchemaField = {
  name: string;
  offset: number; // 0-based, relative to start of record
  type: FieldType;
  length?: number; // required for ascii_fixed
  note?: string;
};

type Schema = {
  file: string;
  recordSize: number;
  recordHeader: {
    marker: { offset: number; type: "u8"; value: number; note?: string };
    workerId: { offset: number; type: "u16le" };
    dataStartsAt: number;
  };
  fields: SchemaField[];
  mappings?: Record<string, any>;
  notes?: string[];
};

export type Worker = {
  index: number;
  id: number;
  [key: string]: any;
};

function assertSchema(schema: Schema) {
  if (!schema?.recordSize || schema.recordSize <= 0) {
    throw new Error("Schema invalid: recordSize missing/invalid");
  }
  if (!schema.recordHeader?.marker) {
    throw new Error("Schema invalid: recordHeader.marker missing");
  }
  if (!schema.recordHeader?.workerId) {
    throw new Error("Schema invalid: recordHeader.workerId missing");
  }
  if (!Array.isArray(schema.fields)) {
    throw new Error("Schema invalid: fields missing/invalid");
  }

  for (const f of schema.fields) {
    if (typeof f.name !== "string" || !f.name) {
      throw new Error("Schema invalid: a field has no name");
    }
    if (typeof f.offset !== "number" || f.offset < 0) {
      throw new Error(`Schema invalid: field "${f.name}" has invalid offset`);
    }
    if (f.type === "ascii_fixed") {
      if (typeof f.length !== "number" || f.length <= 0) {
        throw new Error(
          `Schema invalid: field "${f.name}" ascii_fixed missing length`
        );
      }
    }
  }
}

class Bin {
  private view: DataView;
  private bytes: Uint8Array;

  constructor(arrayBuffer: ArrayBuffer) {
    this.view = new DataView(arrayBuffer);
    this.bytes = new Uint8Array(arrayBuffer);
  }

  size(): number {
    return this.bytes.length;
  }

  u8(offset: number): number {
    return this.view.getUint8(offset);
  }

  u16le(offset: number): number {
    return this.view.getUint16(offset, true);
  }

  asciiFixed(offset: number, length: number): string {
    const slice = this.bytes.slice(offset, offset + length);

    let s = "";
    for (let i = 0; i < slice.length; i++) {
      const c = slice[i];
      if (c === 0x00) break;
      s += String.fromCharCode(c);
    }

    return s.replace(/\0/g, "").trim();
  }
}

export function parseWrestlerDat(arrayBuffer: ArrayBuffer): Worker[] {
  const schema = schemaJson as unknown as Schema;
  assertSchema(schema);

  const bin = new Bin(arrayBuffer);

  const recordSize = schema.recordSize;
  const markerOffset = schema.recordHeader.marker.offset;
  const markerValue = schema.recordHeader.marker.value;
  const idOffset = schema.recordHeader.workerId.offset;

  const fileSize = bin.size();
  if (fileSize < recordSize) {
    throw new Error(
      `File too small: ${fileSize} bytes (expected at least ${recordSize})`
    );
  }
  if (fileSize % recordSize !== 0) {
    throw new Error(
      `File size ${fileSize} is not a multiple of recordSize ${recordSize}.`
    );
  }

  const totalRecords = fileSize / recordSize;
  const workers: Worker[] = [];

  for (let index = 0; index < totalRecords; index++) {
    const recordStart = index * recordSize;

    const marker = bin.u8(recordStart + markerOffset);
    if (marker !== markerValue) {
      throw new Error(
        `Invalid record marker at index ${index} (offset ${
          recordStart + markerOffset
        }). Expected ${markerValue}, got ${marker}.`
      );
    }

    const id = bin.u16le(recordStart + idOffset);

    const w: Worker = { index, id };

    for (const f of schema.fields) {
      const abs = recordStart + f.offset;

      if (f.type === "u8") {
        if (abs < 0 || abs >= fileSize) {
          throw new Error(`Out of bounds read for "${f.name}" at ${abs}`);
        }
        w[f.name] = bin.u8(abs);
      } else if (f.type === "u16le") {
        if (abs < 0 || abs + 1 >= fileSize) {
          throw new Error(`Out of bounds read for "${f.name}" at ${abs}`);
        }
        w[f.name] = bin.u16le(abs);
      } else if (f.type === "ascii_fixed") {
        const len = f.length ?? 0;
        if (abs < 0 || abs + len > fileSize) {
          throw new Error(
            `Out of bounds read for "${f.name}" at ${abs} len ${len}`
          );
        }
        w[f.name] = bin.asciiFixed(abs, len);
      } else {
        throw new Error(`Unsupported field type "${(f as any).type}"`);
      }
    }

    // Convenience normalized fields (non-destructive)
    if (typeof w.birthMonthRaw === "number") w.birthMonth = w.birthMonthRaw & 0xff;
    if (typeof w.weightRaw === "number") w.weight = w.weightRaw & 0xff;
    if (typeof w.ageRaw === "number") w.age = w.ageRaw & 0xff;
    if (typeof w.wageThousandsRaw === "number") w.wageDollars = w.wageThousandsRaw * 1000;

    workers.push(w);
  }

  return workers;
}
